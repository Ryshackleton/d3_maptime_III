<!DOCTYPE html>
<html lang="en">
<!--Header info, scripts, etc-->
<head>
    <meta charset="UTF-8">
    <title>D3 Intro Map</title>
    <!--D3 version 4-->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <!--TopoJSON version 3-->
    <script src="https://unpkg.com/topojson@3"></script>
</head>

<!--css -->
<style>
    body {
        padding: 10px;
        margin: 0;
    }
    path {
        fill: whitesmoke;
        stroke: black;
        stroke-width: 1px;
    }
    .map-container {
        height: 80vh;
    }
    svg {
        width: 100%;
        height: 100%;
    }
</style>

<!--page content-->
<body>
    <h1>D3 Intro Map</h1>
    <div class="map-container"></div>

<!--JavaScript-->
<script>
    /** parse the king county TopoJSON, and pass the results to
     * the buildChoroplethMap() function */
    d3.json('data/king_county_census_tracts.json', buildChoroplethMap);

    /** take the result of parsing the topojson using d3.json() and build the map */
    function buildChoroplethMap(topology) {
      /** convert the compressed TopoJSON (topology) -> GeoJSON and get each layer */
      var censusTractsGeoJSON = topojson.feature(topology, topology.objects.census_tracts);

      /** Get size of the window, and compute some sizing parameters relative to the window
       * ...these will be used by projection.fitExtent() below to size and scale the map */
      var mapWidth = window.innerWidth * 0.8;  // map width will be 80% of the view height (pixels)
      var mapHeight = window.innerHeight * 0.8; // map height will be 80% of the view height (pixels)
      var mapWidthHeight = d3.min([mapWidth, mapHeight]); // take the minimum, and make it square (pixels)
      var mapPadddingTop = 0; // padding around map geometry (pixels)
      var mapPadddingLeft = 100; // padding around map geometry (pixels)

      /** find the centroid of the topology in long, lat */
      var mapCentroid = d3.geoCentroid(censusTractsGeoJSON); // [longitude, latitude]
      var longitudinalRotation = -mapCentroid[0]; // longitude

      /** Create a projection that takes [longitude, latitude] and returns screen coordinates
       *    [X, Y] in pixels
       *    * Below, the longitudinal rotation (rotate([longitude, 0, 0])) "moves" the projection
       *     to where our map is in longitude,
       *    * Then, fitExtent() fits the map to the width and height, based on the bounding box
       *     of the geoJSON we passed in
       *  ***This assumes that the topology is in an un-projected coordinate system
       *       (ie, lat/long values)****
       *  (try replacing geoAlbers() with any other projection here:
       *       https://github.com/d3/d3-geo/blob/master/README.md#geoAzimuthalEqualArea)
       */
      var projection = d3.geoAlbers()
        .rotate([longitudinalRotation, 0])
        .fitExtent([[mapPadddingLeft, mapPadddingTop], [mapWidthHeight, mapWidthHeight]], censusTractsGeoJSON);

      /** The geoPath takes in arrays of [long, lat] values and converts them to svg <path> objects */
      var geoPath = d3.geoPath()
        .projection(projection);

      /** select the div with the class 'map-container', and add an svg to it,
       *  store the svg "selection" as svg_selection */
      var svg_selection = d3.select('.map-container')
        .append('svg');

      /** append a group (g) to the svg */
      svg_selection.append('g')
      /** add the class name 'census_tracts' to the group */
        .classed('census_tracts', true)
        /** select any existing path nodes (there aren't any, but this also tells d3 that we're about to join some data to paths) */
        .selectAll('path')
        /** create a data join with the array of census tract boundaries (enter, update, exit are the 'selections') */
        .data(censusTractsGeoJSON.features)
        /** get the objects representing new data coming into the view 'enter selection' */
        .enter()
        /** append an svg <path> node to each of the newly entering objects */
        .append('path')
        /** add the class name 'census_tract_boundary' to each path */
        .classed('census_tract_boundary', true)
        /** the 'd' attribute represents the drawing instructions for each path (line), so set the geoPath function to get that line drawing */
        .attr('d', geoPath);
    }
</script>
</body>
</html>
